node.parent
n
node.parent
n
node.parent
n
node.parent
node.parent.value
n
node.parent.value
s
n
node
c
last_node
exit
n
list=
starting_node_moves.empty?
if starting_node_moves.empty?
unless starting_node_moves.empty?
list 40-43
list=
list
list1
list-1
list=
starting_node_moves
n
s
n
exit
n
starting_node_moves
child_polyTreeNode
n
starting_node_moves
s
starting_node_moves
n
exit
@root_node.children
@root_node
target
exit
last_node
skip
exit
starting_node_moves.unshift
starting_node_moves.shift
starting_node_moves
node
c
pos
c
pos
exit
pos
c
pos
c
pos
exit
list=
where
wtf?
wtf
pos
c
pos
skip
c
index_previous_node
n
exit
index_previous_node
n
exit
return_list.find_index { |node| node.value == next_node_in_path.parent.value }
return_list.find_index { |node| node.value == next_node_in_path.value }
@root_node.value
next_node_in_path.value
n
next_node_in_path.parent.value
next_node_in_path.parent
next_node_in_path
n
return_list.size
return_list
finish
n
path_list
n
exit
return_list[1].parent.value
return_list[1].parent
return_list[2].parent
return_list[2].value
return_list[1].value
return_list[0].value
return_list[0].children
return_list[0.children]
return_list[0]
return_list
exit
display list
list
skip
exit
skip
c
n
list=
startingNode.children
p startingNode
startingNode
n
self.value
self
node.parent
node
s
node
list=
p children_nodes
children_nodes
s
list=
polyNodes.size
polyNodes
polyNodes[5]
polyNodes[4]
polyNodes[3]
polyNodes[2]
polyNodes[1]
polyNodes[0]
polyNodes
n
s
n
pos
s
n
exit
starting_node_moves.map { |pos| PolyTreeNode.new(pos)}
polyNodes
n
s
starting_node_moves
n
skip
c
n
starting_node_moves
n
exit
@considered_positions
valid_moves(pos).reject{ |move| @considered_positions.include?(move) }
valid_moves(pos)
new_move_positions
n
s
exit
knight.build_move_tree(knight.root_node)
knight = KnightPathFinder.new([0,0])
knight.build_move_tree(knight.root_node)
starting_node_moves
n
